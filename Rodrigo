import tkinter as tk
from tkinter import ttk
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from PIL import Image, ImageTk
import re
import time

# Crear la ventana principal
ventana = tk.Tk()

# Obtener el tamaño de la pantalla
anPanta = ventana.winfo_screenwidth()
alPanta = ventana.winfo_screenheight()

# Se parte la pantalla en cuatro partes
anCuarto = anPanta // 2
alCuarto = alPanta // 2

# Crear los marcos para cada cuarto de la pantalla
marco_1 = tk.Frame(ventana, width=anCuarto, height=alCuarto, bg='#CC99FF')
marco_2 = tk.Frame(ventana, width=anCuarto, height=alCuarto, bg = 'blue')
marco_3 = tk.Frame(ventana, width=anCuarto, height=alCuarto, bg='#99CCFF')
marco_4 = tk.Frame(ventana, width=anCuarto, height=alCuarto, bg='#FFFF99')

# Se le asigna a cada marco una matriz y se colocan los marcos en la ventana
marco_1.grid(row=0, column=0)
marco_2.grid(row=0, column=1)
marco_3.grid(row=1, column=0, sticky="nsew")
marco_4.grid(row=1, column=1)


############################################################################
#                               Caja
############################################################################

class Cajas:
    def __init__(self, marco_1): # self se utiliza para acceder y asignar atributos específicos a dicha instancia.

        # crea el cuadrado dentro del marco 1
        self.box = tk.Frame(marco_1, width=50, height=50, bg='#683343')
        self.box.pack()

    def limites(self):

        # Obtener las dimensiones del marco
        ancho_marco = marco_1.winfo_width()
        alto_marco = marco_1.winfo_height()

        # Calcular las nuevas coordenadas
        nueva_x = self.box.winfo_x()
        nueva_y = self.box.winfo_y()

        # Verificar los límites del rectángulo
        if 0 <= nueva_x <= ancho_marco - self.box.winfo_width():
            if 0 <= nueva_y <= alto_marco - self.box.winfo_height():
                self.box.place(x=nueva_x, y=nueva_y)

        marco_1.after(1, self.limites)

    def mover(self, velocidad_x, direccion_x):
        nueva_x = self.box.winfo_x() + (velocidad_x * direccion_x)
        nueva_y = self.box.winfo_y()

        self.box.place(x=nueva_x, y=nueva_y)


# Crear instancia de Cajas dentro del marco 1
caja1 = Cajas(marco_1)

# Establecer la posición inicial del cuadrado
caja1.box.place(x=anPanta//2//2, y=alPanta//2 - 55)


############################################################################
#                               Personaje
############################################################################
class Personajes:
    def __init__(self, imaP=None, caja=None):
        self.imaP_1 = imaP
        self.x = 0
        self.y = 0

        self.caja = caja

        self.velocidad_x = 1  # Velocidad en el eje x
        self.direccion_x = 1  # Dirección del movimiento (1 para derecha, -1 para izquierda)

        # Cargar las imágenes del personaje
        self.sprite_images = []
        for i in range(6):  # Suponiendo que hay 12 imágenes del personaje
            image_path = f"c{i}.png"
            image = Image.open(image_path).convert("RGBA")
            image = image.resize((50, 50))  # Ajustar el tamaño de la imagen
            self.sprite_images.append(ImageTk.PhotoImage(image))

        self.current_frame = 0  # Cuadro actual de la animación

        # Crear una etiqueta para mostrar la imagen del personaje
        self.etiqueta = tk.Label(self.imaP_1)
        self.etiqueta.config(bg='#CC99FF')
        self.etiqueta.place(x=anCuarto//2-70, y=alPanta//2 - 55)  # Colocar la etiqueta en la esquina superior izquierda de imaP_1

        # Configurar la imagen inicial del personaje
        self.etiqueta.config(image=self.sprite_images[0])

        self.move_enabled = False

        # Enlazar los eventos de teclado a los métodos de movimiento
        ventana.bind("<KeyPress-a>", lambda e: self.izquierda(e))
        ventana.bind("<KeyPress-d>", lambda e: self.derecha(e))

        self.limites()

    def animate(self):
        if self.move_enabled:
            self.current_frame += 1
            if self.current_frame >= len(self.sprite_images):
                self.current_frame = 0

            self.etiqueta.config(image=self.sprite_images[self.current_frame])

        self.move_enabled = False
        self.imaP_1.after(2, self.animate)  # Cambiar el cuadro de la animación cada 100 milisegundos

    def limites(self):
        if self.move_enabled:
            # Obtener las dimensiones del marco
            ancho_marco = self.imaP_1.winfo_width()
            alto_marco = self.imaP_1.winfo_height()

            # Calcular las nuevas coordenadas
            nueva_x = self.etiqueta.winfo_x() + (self.velocidad_x * self.direccion_x)
            nueva_y = self.etiqueta.winfo_y() + self.y

            # Verificar los límites del rectángulo
            if 0 <= nueva_x <= ancho_marco - self.etiqueta.winfo_width():
                if 0 <= nueva_y <= alto_marco - self.etiqueta.winfo_height():
                    self.etiqueta.place(x=nueva_x, y=nueva_y)

            self.caja.mover(self.velocidad_x, self.direccion_x)

        self.move_enabled = False
        self.imaP_1.after(1, self.limites)

    # Movimiento a la izquierda
    def izquierda(self, event):
        self.velocidad_x = self.velocidad_x
        self.direccion_x = -1
        self.y = 0
        self.move_enabled = True

    # Movimiento a la derecha
    def derecha(self, event):
        self.velocidad_x = self.velocidad_x
        self.direccion_x = 1
        self.y = 0
        self.move_enabled = True


# Crear una instancia de la clase Personajes
per1 = Personajes(marco_1, caja1)

# Enlazar los eventos de teclado a los métodos de movimiento
ventana.bind("<KeyPress-a>", lambda e: per1.izquierda(e))
ventana.bind("<KeyPress-d>", lambda e: per1.derecha(e))
per1.animate()


############################################################################
#                               Grafico
############################################################################

# Crear la figura del gráfico
figura = Figure(figsize=(anPanta // 2 / 100, alPanta // 2 / 100), dpi=100)
grafico = figura.add_subplot(111)

# Agregar el gráfico a la ventana
canvas = FigureCanvasTkAgg(figura, master=marco_2)
canvas.draw()
canvas.get_tk_widget().pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

# Lista para almacenar los datos del gráfico
datos_grafico = []

# Función para actualizar el gráfico
def actualizar_grafico():
    grafico.clear()
    fuerzas, distancias, trabajos = zip(*datos_grafico)
    grafico.plot(distancias, fuerzas, marker='o', linestyle='-')
    grafico.set_xlabel("Distancia (m)")
    grafico.set_ylabel("Fuerza (N)")
    grafico.set_title("Gráfico de Trabajo Mecánico")
    grafico.grid(True)
    canvas.draw()


############################################################################
#                               Tabla
############################################################################

# Crear el ScrollableFrame para la tabla
scrollable_frame = tk.Frame(marco_4)
scrollable_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

# Crear la tabla dentro del ScrollableFrame
tabla = ttk.Treeview(scrollable_frame)
tabla.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

# Definir las columnas de la tabla
tabla['columns'] = ("N°", "Fuerza", "Distancia", "Trabajo")

# Formato de las columnas
tabla.column("#0", width=0, stretch=tk.NO)
tabla.column("N°", width=50, anchor=tk.CENTER)
tabla.column("Fuerza", width=200, anchor=tk.CENTER)
tabla.column("Distancia", width=200, anchor=tk.CENTER)
tabla.column("Trabajo", width=200, anchor=tk.CENTER)

# Encabezados de las columnas
tabla.heading("#0", text="", anchor=tk.CENTER)
tabla.heading("N°", text="N°", anchor=tk.CENTER)
tabla.heading("Fuerza", text="Fuerza (N)", anchor=tk.CENTER)
tabla.heading("Distancia", text="Distancia (m)", anchor=tk.CENTER)
tabla.heading("Trabajo", text="Trabajo (J)", anchor=tk.CENTER)

# Función para actualizar la tabla con los datos almacenados
def actualizar_tabla():
    # Limpiar los datos anteriores de la tabla
    tabla.delete(*tabla.get_children())
    
    # Agregar los datos a la tabla
    for i, (fuerza, distancia, trabajo) in enumerate(datos_grafico, start=1):
        tabla.insert("", "end", text=str(i), values=(i, fuerza, distancia, trabajo))

# Configurar el desplazamiento en el ScrollableFrame
scrollbar = ttk.Scrollbar(scrollable_frame, orient="vertical", command=tabla.yview)
tabla.configure(yscrollcommand=scrollbar.set)
scrollbar.pack(side=tk.RIGHT, fill=tk.Y)


############################################################################
#                               Calculo
############################################################################
datos_registro= []
# Crear los widgets para ingresar los datos
label_fuerza = tk.Label(marco_3, text="Fuerza (N):")
label_fuerza.pack()

entry_fuerza = tk.Entry(marco_3, justify="center")
entry_fuerza.pack()

label_distancia = tk.Label(marco_3, text="Distancia (m):")
label_distancia.pack()

label_distancia2 = tk.Label(marco_3, text="")
label_distancia2.pack()

entry_distancia = tk.Entry(marco_3, justify="center")
entry_distancia.pack()

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Función para validar la entrada
def validar_entrada(text):
    return re.match(r'^\d*\.?\d*$', text) is not None

# Asociar la función de validación a los campos de entrada
valCom = (ventana.register(validar_entrada), '%P')

entry_fuerza.config(validate="key", validatecommand=valCom)
#entry_distancia.config(validate="key", validatecommand=valCom)


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def actualizar_velocidad_x():
    global nueva_velocidad
    try:
        nueva_velocidad = int(entry_velocidad.get())
        per1.velocidad_x = nueva_velocidad
    except ValueError:
        # Manejar el caso en el que se ingrese un valor no válido
        pass
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# Función para calcular el trabajo
def calcular_trabajo():
    global nueva_velocidad
    try:
        fuerza = float(entry_fuerza.get())

        tiempo_transcurrido = cronometro.tiempo_transcurrido()

        distancia = tiempo_transcurrido * nueva_velocidad

        label_distancia2.config(text=f"La distancia es: {distancia} J")

        trabajo = fuerza * distancia

        label_resultado.config(text=f"El trabajo es: {trabajo} J")

        # Agregar los datos a la lista del gráfico
        datos_grafico.append((fuerza, distancia, trabajo))

        # Actualizar el gráfico y la tabla
        actualizar_grafico()
        actualizar_tabla()

        # Limpiar los campos de entrada
        entry_fuerza.delete(0, tk.END)
        #entry_distancia.delete(0, tk.END)

    except ValueError:
        label_resultado.config(text="Ingrese valores numéricos válidos")
    datos_registro.append((fuerza, distancia))


def limites(self):
    if self.move_enabled:
        # Obtener las dimensiones del marco
        ancho_marco = self.imaP_1.winfo_width()
        alto_marco = self.imaP_1.winfo_height()

        # Obtener la posición actual del personaje
        x_actual = self.etiqueta.winfo_x()
        y_actual = self.etiqueta.winfo_y()

        # Verificar si hay datos en el registro
        if datos_registro:
            # Obtener el último dato de fuerza y distancia ingresados
            fuerza, distancia = datos_registro[-1]

            # Calcular las nuevas coordenadas
            nueva_x = x_actual + (self.velocidad_x * self.direccion_x * distancia)
            nueva_y = y_actual + (self.y * distancia)

            # Verificar los límites del rectángulo
            if 0 <= nueva_x <= ancho_marco - self.etiqueta.winfo_width():
                if 0 <= nueva_y <= alto_marco - self.etiqueta.winfo_height():
                    self.etiqueta.place(x=nueva_x, y=nueva_y)

        self.move_enabled = False
        self.imaP_1.after(1, self.limites)
   
# Botón para calcular el trabajo
btn_calcular = tk.Button(marco_3, text="Calcular", command=calcular_trabajo)
btn_calcular.pack()

# Etiqueta para mostrar el resultado
label_resultado = tk.Label(marco_3, text="")
label_resultado.pack()


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#                               Velocidad
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

label_velocidad = tk.Label(marco_3, text="Velocidad(m/s):")
label_velocidad.pack()

entry_velocidad = tk.Entry(marco_3, justify="center")
entry_velocidad.pack()

# Crear el botón para actualizar la velocidad en x
boton_actualizar = tk.Button(marco_3, text="Actualizar", command=actualizar_velocidad_x)
boton_actualizar.pack()

# Función para validar la entrada
entry_velocidad.config(validate="key", validatecommand=valCom)


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#                               Tiempo
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class Cronometro:
    def __init__(self, ventana):
        self.ventana = ventana
        self.iniciado = False
        self.tiempo_inicial = 0
        self.etiqueta_tiempo = tk.Label(ventana, text="Tiempo: 0 segundos")
        self.etiqueta_tiempo.pack()

        boton = tk.Button(ventana, text="Iniciar/Detener", command=self.iniciar_detener_cronometro)
        boton.pack()


    def iniciar_detener_cronometro(self):
        if not self.iniciado:
            self.iniciado = True
            self.tiempo_inicial = time.time()
            self.actualizar_cronometro()
        else:
            self.iniciado = False

    def actualizar_cronometro(self):
        if self.iniciado:
            tiempo_transcurrido = int(time.time() - self.tiempo_inicial)
            self.etiqueta_tiempo.config(text=f"Tiempo: {tiempo_transcurrido} segundos")
            self.ventana.after(1000, self.actualizar_cronometro)

cronometro = Cronometro(marco_3)

cronometro.etiqueta_tiempo.pack()


# Darle el enfoque a la ventana para recibir eventos de teclado
ventana.focus_set()
# Iniciar el bucle de eventos
ventana.mainloop()
