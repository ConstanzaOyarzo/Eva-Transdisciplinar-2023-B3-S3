import tkinter as tk
from tkinter import ttk
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from PIL import Image, ImageTk
import re

# Crear la ventana principal
ventana = tk.Tk()

# Obtener el tamaño de la pantalla
anPanta = ventana.winfo_screenwidth()
alPanta = ventana.winfo_screenheight()

# Se parte la pantalla en cuatro partes
anCuarto = anPanta // 2
alCuarto = alPanta // 2

# Crear los marcos para cada cuarto de la pantalla
marco_1 = tk.Frame(ventana, width=anCuarto,height=alCuarto, bg='#CC99FF')
marco_2 = tk.Frame(ventana, width=anCuarto, height=alCuarto, bg = 'blue')
marco_3 = tk.Frame(ventana, width=anCuarto, height=alCuarto, bg='#99CCFF')
marco_4 = tk.Frame(ventana, width=anCuarto, height=alCuarto, bg='#FFFF99')

# Se le asigna a cada marco una matriz y se colocan los marcos en la ventana
marco_1.grid(row=0, column=0)
marco_2.grid(row=0, column=1)
marco_3.grid(row=1, column=0)
marco_4.grid(row=1, column=1)


############################################################################
#                               Caja
############################################################################

class Cajas:
    def __init__(self, marco_1): # self se utiliza para acceder y asignar atributos específicos a dicha instancia.

        # crea el cuadrado dentro del marco 1
        self.box = tk.Frame(marco_1, width=50, height=50, bg='#683343')
        self.box.pack()

    def limites(self):

        # Obtener las dimensiones del marco
        ancho_marco = marco_1.winfo_width()
        alto_marco = marco_1.winfo_height()

        # Calcular las nuevas coordenadas
        nueva_x = self.box.winfo_x()
        nueva_y = self.box.winfo_y()

        # Verificar los límites del rectángulo
        if 0 <= nueva_x <= ancho_marco - self.box.winfo_width():
            if 0 <= nueva_y <= alto_marco - self.box.winfo_height():
                self.box.place(x=nueva_x, y=nueva_y)

        marco_1.after(1, self.limites)


# Crear instancia de Cajas dentro del marco 1
caja1 = Cajas(marco_1)

# Establecer la posición inicial del rectángulo en la esquina inferior izquierda
caja1.box.place(x=anPanta//2//2, y=alPanta//2 - 55)


############################################################################
#                               Personaje
############################################################################
class Personajes:
    def __init__(self, imaP=None):
        self.imaP_1 = imaP
        self.x = 0
        self.y = 0

        # Cargar la imagen del personaje
        self.imaP = Image.open("cosa.png").convert("RGBA")  # Convertir la imagen a modo RGBA
        self.imaP = self.imaP.resize((50, 50))  # Ajustar el tamaño de la imagen
        self.imaP_tk = ImageTk.PhotoImage(self.imaP)

        # Crear una etiqueta para mostrar la imagen del personaje
        self.posicion_i = tk.Label(self.imaP_1, image=self.imaP_tk)
        self.posicion_i.config(image=self.imaP_tk, bg='#CC99FF')
        self.posicion_i.place(x=anCuarto//2-70, y=alPanta//2 - 55)  # Colocar la etiqueta en la esquina superior izquierda de imaP_1
        self.move_enabled = False


        # Función para controlar el movimiento del personaje
    def movimiento(self):
        if self.move_enabled:
            # Obtener las dimensiones del marco
            ancho_marco = self.imaP_1.winfo_width()
            alto_marco = self.imaP_1.winfo_height()

            # Calcular las nuevas coordenadas
            nueva_x = self.posicion_i.winfo_x() + self.x
            nueva_y = self.posicion_i.winfo_y() + self.y

            # Verificar los límites del rectángulo
            if 0 <= nueva_x <= ancho_marco - self.posicion_i.winfo_width():
                if 0 <= nueva_y <= alto_marco - self.posicion_i.winfo_height():
                    self.posicion_i.place(x=nueva_x, y=nueva_y)

        self.move_enabled = False
        self.imaP_1.after(1, self.movimiento)

    # movmiento a la izquierda
    def izquierda(self, event):
        self.x = -5
        self.y = 0
        self.move_enabled = True

    # movimiento a la derecha
    def derecha(self, event):
        self.x = 5
        self.y = 0
        self.move_enabled = True

    # movimiento hacia arriba
    def arriba(self, event):
        self.x = 0
        self.y = -5
        self.move_enabled = True

    # movimiento hacia abajo
    def abajo(self, event):
        self.x = 0
        self.y = 5
        self.move_enabled = True

    # movimiento diagonal arriba-derecha
    def diagonal_arriba_derecha(self, event):
        self.x = 5
        self.y = -5
        self.move_enabled = True

    # movimiento diagonal arriba-izquierda
    def diagonal_arriba_izquierda(self, event):
        self.x = -5
        self.y = -5
        self.move_enabled = True

# Crear una instancia de la clase GFG
per1 = Personajes(marco_1)

# Enlazar los eventos de teclado a los métodos de movimiento
ventana.bind("<KeyPress-w>", lambda e: per1.arriba(e))
ventana.bind("<KeyPress-a>", lambda e: per1.izquierda(e))
ventana.bind("<KeyPress-s>", lambda e: per1.abajo(e))
ventana.bind("<KeyPress-d>", lambda e: per1.derecha (e))
ventana.bind("<KeyPress-e>", lambda e: per1.diagonal_arriba_derecha(e))
ventana.bind("<KeyPress-q>", lambda e: per1.diagonal_arriba_izquierda(e))
ventana.after(0, per1.movimiento)



############################################################################
#                               Grafico
############################################################################

# Crear la figura del gráfico
figura = Figure(figsize=(anPanta // 2 / 100, alPanta // 2 / 100), dpi=100)
grafico = figura.add_subplot(111)

# Agregar el gráfico a la ventana
canvas = FigureCanvasTkAgg(figura, master=marco_2)
canvas.draw()
canvas.get_tk_widget().pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

# Lista para almacenar los datos del gráfico
datos_grafico = []

# Función para actualizar el gráfico
def actualizar_grafico():
    grafico.clear()
    fuerzas, distancias, trabajos = zip(*datos_grafico)
    grafico.plot(distancias, fuerzas, marker='o', linestyle='-')
    grafico.set_xlabel("Distancia (m)")
    grafico.set_ylabel("Fuerza (N)")
    grafico.set_title("Gráfico de Trabajo Mecánico")
    grafico.grid(True)
    canvas.draw()

############################################################################
#                               Tabla
############################################################################

# Crear el ScrollableFrame para la tabla
scrollable_frame = tk.Frame(marco_4)
scrollable_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

# Crear la tabla dentro del ScrollableFrame
tabla = ttk.Treeview(scrollable_frame)
tabla.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

# Definir las columnas de la tabla
tabla['columns'] = ("N°", "Fuerza", "Distancia", "Trabajo")

# Formato de las columnas
tabla.column("#0", width=0, stretch=tk.NO)
tabla.column("N°", width=50, anchor=tk.CENTER)
tabla.column("Fuerza", width=200, anchor=tk.CENTER)
tabla.column("Distancia", width=200, anchor=tk.CENTER)
tabla.column("Trabajo", width=200, anchor=tk.CENTER)

# Encabezados de las columnas
tabla.heading("#0", text="", anchor=tk.CENTER)
tabla.heading("N°", text="N°", anchor=tk.CENTER)
tabla.heading("Fuerza", text="Fuerza (N)", anchor=tk.CENTER)
tabla.heading("Distancia", text="Distancia (m)", anchor=tk.CENTER)
tabla.heading("Trabajo", text="Trabajo (J)", anchor=tk.CENTER)

# Función para actualizar la tabla con los datos almacenados
def actualizar_tabla():
    # Limpiar los datos anteriores de la tabla
    tabla.delete(*tabla.get_children())
    
    # Agregar los datos a la tabla
    for i, (fuerza, distancia, trabajo) in enumerate(datos_grafico, start=1):
        tabla.insert("", "end", text=str(i), values=(i, fuerza, distancia, trabajo))

# Configurar el desplazamiento en el ScrollableFrame
scrollbar = ttk.Scrollbar(scrollable_frame, orient="vertical", command=tabla.yview)
tabla.configure(yscrollcommand=scrollbar.set)
scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

############################################################################
#                               Calculo
############################################################################

# Crear los widgets para ingresar los datos
label_fuerza = tk.Label(marco_3, text="Fuerza (N):")
label_fuerza.pack()

entry_fuerza = tk.Entry(marco_3, width=anCuarto//9, justify="center")
entry_fuerza.pack()

label_distancia = tk.Label(marco_3, text="Distancia (m):")
label_distancia.pack()

entry_distancia = tk.Entry(marco_3, width=anCuarto//9, justify="center")
entry_distancia.pack()

# Función para validar la entrada
def validar_entrada(text):
    return re.match(r'^\d*\.?\d*$', text) is not None

# Asociar la función de validación a los campos de entrada
vcmd = (ventana.register(validar_entrada), '%P')

entry_fuerza.config(validate="key", validatecommand=vcmd)
entry_distancia.config(validate="key", validatecommand=vcmd)

# Función para calcular el trabajo
def calcular_trabajo():
    try:
        fuerza = float(entry_fuerza.get())
        distancia = float(entry_distancia.get())

        trabajo = fuerza * distancia

        label_resultado.config(text=f"El trabajo es: {trabajo} J")

        # Agregar los datos a la lista del gráfico
        datos_grafico.append((fuerza, distancia, trabajo))

        # Actualizar el gráfico y la tabla
        actualizar_grafico()
        actualizar_tabla()

        # Limpiar los campos de entrada
        entry_fuerza.delete(0, tk.END)
        entry_distancia.delete(0, tk.END)

    except ValueError:
        label_resultado.config(text="Ingrese valores numéricos válidos")

# Botón para calcular el trabajo
btn_calcular = tk.Button(marco_3, text="Calcular", command=calcular_trabajo)
btn_calcular.pack()

# Etiqueta para mostrar el resultado
label_resultado = tk.Label(marco_3, text="")
label_resultado.pack()

# Darle el enfoque a la ventana para recibir eventos de teclado
ventana.focus_set()
# Iniciar el bucle de eventos
ventana.mainloop()
